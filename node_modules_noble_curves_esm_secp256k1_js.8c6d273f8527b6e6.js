"use strict";(self.webpackChunkNFTCreatorForChrome=self.webpackChunkNFTCreatorForChrome||[]).push([["node_modules_noble_curves_esm_secp256k1_js"],{58977:(Ln,fe,ht)=>{ht.r(fe),ht.d(fe,{encodeToCurve:()=>Tn,hashToCurve:()=>Cn,schnorr:()=>qn,secp256k1:()=>Ot});var zt={};ht.r(zt),ht.d(zt,{aK:()=>rt,e8:()=>gt,DO:()=>X,dJ:()=>ge,OG:()=>Kt,My:()=>wt,Ph:()=>Q,lX:()=>Pt,Id:()=>D,fg:()=>me,qj:()=>M,aT:()=>bt,r4:()=>yt,aY:()=>ut,x:()=>Gt,lq:()=>nt,z:()=>jt,zW:()=>mt,AI:()=>Rt,Q5:()=>pt});var at=ht(37099),U=ht(68670);function ze(t,n,e){return t&n^~t&e}function Pe(t,n,e){return t&n^t&e^n&e}class je extends U.Vw{constructor(n,e,r,o){super(),this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=(0,U.O8)(this.buffer)}update(n){(0,at.CC)(this);const{view:e,buffer:r,blockLen:o}=this,s=(n=(0,U.ZJ)(n)).length;for(let c=0;c<s;){const f=Math.min(o-this.pos,s-c);if(f!==o)r.set(n.subarray(c,c+f),this.pos),this.pos+=f,c+=f,this.pos===o&&(this.process(e,0),this.pos=0);else{const i=(0,U.O8)(n);for(;o<=s-c;c+=o)this.process(i,c)}}return this.length+=n.length,this.roundClean(),this}digestInto(n){(0,at.CC)(this),(0,at.Ht)(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:o,isLE:s}=this;let{pos:c}=this;e[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>o-c&&(this.process(r,0),c=0);for(let l=c;l<o;l++)e[l]=0;(function Me(t,n,e,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(n,e,r);const o=BigInt(32),s=BigInt(4294967295),c=Number(e>>o&s),f=Number(e&s),i=r?4:0,a=r?0:4;t.setUint32(n+i,c,r),t.setUint32(n+a,f,r)})(r,o-8,BigInt(8*this.length),s),this.process(r,0);const f=(0,U.O8)(n),i=this.outputLen;if(i%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=i/4,d=this.get();if(a>d.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<a;l++)f.setUint32(4*l,d[l],s)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:o,finished:s,destroyed:c,pos:f}=this;return n.length=o,n.pos=f,n.finished=s,n.destroyed=c,o%e&&n.buffer.set(r),n}}const De=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),tt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),et=new Uint32Array(64);class ae extends je{constructor(){super(64,32,8,!1),this.A=0|tt[0],this.B=0|tt[1],this.C=0|tt[2],this.D=0|tt[3],this.E=0|tt[4],this.F=0|tt[5],this.G=0|tt[6],this.H=0|tt[7]}get(){const{A:n,B:e,C:r,D:o,E:s,F:c,G:f,H:i}=this;return[n,e,r,o,s,c,f,i]}set(n,e,r,o,s,c,f,i){this.A=0|n,this.B=0|e,this.C=0|r,this.D=0|o,this.E=0|s,this.F=0|c,this.G=0|f,this.H=0|i}process(n,e){for(let l=0;l<16;l++,e+=4)et[l]=n.getUint32(e,!1);for(let l=16;l<64;l++){const h=et[l-15],g=et[l-2],v=(0,U.Ow)(h,7)^(0,U.Ow)(h,18)^h>>>3,b=(0,U.Ow)(g,17)^(0,U.Ow)(g,19)^g>>>10;et[l]=b+et[l-7]+v+et[l-16]|0}let{A:r,B:o,C:s,D:c,E:f,F:i,G:a,H:d}=this;for(let l=0;l<64;l++){const g=d+((0,U.Ow)(f,6)^(0,U.Ow)(f,11)^(0,U.Ow)(f,25))+ze(f,i,a)+De[l]+et[l]|0,b=((0,U.Ow)(r,2)^(0,U.Ow)(r,13)^(0,U.Ow)(r,22))+Pe(r,o,s)|0;d=a,a=i,i=f,f=c+g|0,c=s,s=o,o=r,r=g+b|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,c=c+this.D|0,f=f+this.E|0,i=i+this.F|0,a=a+this.G|0,d=d+this.H|0,this.set(r,o,s,c,f,i,a,d)}roundClean(){et.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Ct=(0,U.ld)(()=>new ae);class ue extends U.Vw{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,(0,at.sd)(n);const r=(0,U.ZJ)(e);if(this.iHash=n.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?n.create().update(r).digest():r);for(let c=0;c<s.length;c++)s[c]^=54;this.iHash.update(s),this.oHash=n.create();for(let c=0;c<s.length;c++)s[c]^=106;this.oHash.update(s),s.fill(0)}update(n){return(0,at.CC)(this),this.iHash.update(n),this}digestInto(n){(0,at.CC)(this),(0,at.DO)(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:o,destroyed:s,blockLen:c,outputLen:f}=this;return n.finished=o,n.destroyed=s,n.blockLen=c,n.outputLen=f,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const le=(t,n,e)=>new ue(t,n).update(e).digest();le.create=(t,n)=>new ue(t,n)
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */;const Tt=BigInt(0),Lt=BigInt(1),Ke=BigInt(2);function ut(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function X(t){if(!ut(t))throw new Error("Uint8Array expected")}function gt(t,n){if("boolean"!=typeof n)throw new Error(t+" boolean expected, got "+n)}const Ye=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function wt(t){X(t);let n="";for(let e=0;e<t.length;e++)n+=Ye[t[e]];return n}function mt(t){const n=t.toString(16);return 1&n.length?"0"+n:n}function de(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return""===t?Tt:BigInt("0x"+t)}const J={_0:48,_9:57,A:65,F:70,a:97,f:102};function he(t){return t>=J._0&&t<=J._9?t-J._0:t>=J.A&&t<=J.F?t-(J.A-10):t>=J.a&&t<=J.f?t-(J.a-10):void 0}function bt(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const n=t.length,e=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let o=0,s=0;o<e;o++,s+=2){const c=he(t.charCodeAt(s)),f=he(t.charCodeAt(s+1));if(void 0===c||void 0===f){const i=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+i+'" at index '+s)}r[o]=16*c+f}return r}function Q(t){return de(wt(t))}function Pt(t){return X(t),de(wt(Uint8Array.from(t).reverse()))}function nt(t,n){return bt(t.toString(16).padStart(2*n,"0"))}function jt(t,n){return nt(t,n).reverse()}function M(t,n,e){let r;if("string"==typeof n)try{r=bt(n)}catch(s){throw new Error(t+" must be hex string or Uint8Array, cause: "+s)}else{if(!ut(n))throw new Error(t+" must be hex string or Uint8Array");r=Uint8Array.from(n)}const o=r.length;if("number"==typeof e&&o!==e)throw new Error(t+" of length "+e+" expected, got "+o);return r}function D(...t){let n=0;for(let r=0;r<t.length;r++){const o=t[r];X(o),n+=o.length}const e=new Uint8Array(n);for(let r=0,o=0;r<t.length;r++){const s=t[r];e.set(s,o),o+=s.length}return e}function Rt(t){if("string"!=typeof t)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}const Dt=t=>"bigint"==typeof t&&Tt<=t;function yt(t,n,e){return Dt(t)&&Dt(n)&&Dt(e)&&n<=t&&t<e}function rt(t,n,e,r){if(!yt(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}function ge(t){let n;for(n=0;t>Tt;t>>=Lt,n+=1);return n}const Kt=t=>(Ke<<BigInt(t-1))-Lt,Yt=t=>new Uint8Array(t),we=t=>Uint8Array.from(t);function me(t,n,e){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof n||n<2)throw new Error("qByteLen must be a number");if("function"!=typeof e)throw new Error("hmacFn must be a function");let r=Yt(t),o=Yt(t),s=0;const c=()=>{r.fill(1),o.fill(0),s=0},f=(...l)=>e(o,r,...l),i=(l=Yt())=>{o=f(we([0]),l),r=f(),0!==l.length&&(o=f(we([1]),l),r=f())},a=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const h=[];for(;l<n;){r=f();const g=r.slice();h.push(g),l+=r.length}return D(...h)};return(l,h)=>{let g;for(c(),i(l);!(g=h(a()));)i();return c(),g}}const Ge={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||ut(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function pt(t,n,e={}){const r=(o,s,c)=>{const f=Ge[s];if("function"!=typeof f)throw new Error("invalid validator function");const i=t[o];if(!(c&&void 0===i||f(i,t)))throw new Error("param "+String(o)+" is invalid. Expected "+s+", got "+i)};for(const[o,s]of Object.entries(n))r(o,s,!1);for(const[o,s]of Object.entries(e))r(o,s,!0);return t}function Gt(t){const n=new WeakMap;return(e,...r)=>{const o=n.get(e);if(void 0!==o)return o;const s=t(e,...r);return n.set(e,s),s}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Z=BigInt(0),L=BigInt(1),ot=BigInt(2),We=BigInt(3),Wt=BigInt(4),be=BigInt(5),ye=BigInt(8);function H(t,n){const e=t%n;return e>=Z?e:n+e}function Je(t,n,e){if(n<Z)throw new Error("invalid exponent, negatives unsupported");if(e<=Z)throw new Error("invalid modulus");if(e===L)return Z;let r=L;for(;n>Z;)n&L&&(r=r*t%e),t=t*t%e,n>>=L;return r}function Y(t,n,e){let r=t;for(;n-- >Z;)r*=r,r%=e;return r}function Ut(t,n){if(t===Z)throw new Error("invert: expected non-zero number");if(n<=Z)throw new Error("invert: expected positive modulus, got "+n);let e=H(t,n),r=n,o=Z,s=L,c=L,f=Z;for(;e!==Z;){const a=r/e,d=r%e,l=o-c*a,h=s-f*a;r=e,e=d,o=c,s=f,c=l,f=h}if(r!==L)throw new Error("invert: does not exist");return H(o,n)}function Fe(t){if(t%Wt===We){const n=(t+L)/Wt;return function(r,o){const s=r.pow(o,n);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(t%ye===be){const n=(t-be)/ye;return function(r,o){const s=r.mul(o,ot),c=r.pow(s,n),f=r.mul(o,c),i=r.mul(r.mul(f,ot),c),a=r.mul(f,r.sub(i,r.ONE));if(!r.eql(r.sqr(a),o))throw new Error("Cannot find square root");return a}}return function $e(t){const n=(t-L)/ot;let e,r,o;for(e=t-L,r=0;e%ot===Z;e/=ot,r++);for(o=ot;o<t&&Je(o,n,t)!==t-L;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(1===r){const c=(t+L)/Wt;return function(i,a){const d=i.pow(a,c);if(!i.eql(i.sqr(d),a))throw new Error("Cannot find square root");return d}}const s=(e+L)/ot;return function(f,i){if(f.pow(i,n)===f.neg(f.ONE))throw new Error("Cannot find square root");let a=r,d=f.pow(f.mul(f.ONE,o),e),l=f.pow(i,s),h=f.pow(i,e);for(;!f.eql(h,f.ONE);){if(f.eql(h,f.ZERO))return f.ZERO;let g=1;for(let b=f.sqr(h);g<a&&!f.eql(b,f.ONE);g++)b=f.sqr(b);const v=f.pow(d,L<<BigInt(a-g-1));d=f.sqr(v),l=f.mul(l,v),h=f.mul(h,d),a=g}return l}}(t)}const tn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function pe(t){return pt(t,tn.reduce((r,o)=>(r[o]="function",r),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"}))}function Xt(t,n){const e=void 0!==n?n:t.toString(2).length;return{nBitLength:e,nByteLength:Math.ceil(e/8)}}function xe(t,n,e=!1,r={}){if(t<=Z)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:o,nByteLength:s}=Xt(t,n);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const f=Object.freeze({ORDER:t,isLE:e,BITS:o,BYTES:s,MASK:Kt(o),ZERO:Z,ONE:L,create:i=>H(i,t),isValid:i=>{if("bigint"!=typeof i)throw new Error("invalid field element: expected bigint, got "+typeof i);return Z<=i&&i<t},is0:i=>i===Z,isOdd:i=>(i&L)===L,neg:i=>H(-i,t),eql:(i,a)=>i===a,sqr:i=>H(i*i,t),add:(i,a)=>H(i+a,t),sub:(i,a)=>H(i-a,t),mul:(i,a)=>H(i*a,t),pow:(i,a)=>function en(t,n,e){if(e<Z)throw new Error("invalid exponent, negatives unsupported");if(e===Z)return t.ONE;if(e===L)return n;let r=t.ONE,o=n;for(;e>Z;)e&L&&(r=t.mul(r,o)),o=t.sqr(o),e>>=L;return r}(f,i,a),div:(i,a)=>H(i*Ut(a,t),t),sqrN:i=>i*i,addN:(i,a)=>i+a,subN:(i,a)=>i-a,mulN:(i,a)=>i*a,inv:i=>Ut(i,t),sqrt:r.sqrt||(i=>(c||(c=Fe(t)),c(f,i))),invertBatch:i=>function nn(t,n){const e=new Array(n.length),r=n.reduce((s,c,f)=>t.is0(c)?s:(e[f]=s,t.mul(s,c)),t.ONE),o=t.inv(r);return n.reduceRight((s,c,f)=>t.is0(c)?s:(e[f]=t.mul(s,e[f]),t.mul(s,c)),o),e}(f,i),cmov:(i,a,d)=>d?a:i,toBytes:i=>e?jt(i,s):nt(i,s),fromBytes:i=>{if(i.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+i.length);return e?Pt(i):Q(i)}});return Object.freeze(f)}function Ee(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function ve(t){const n=Ee(t);return n+Math.ceil(n/2)}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Be=BigInt(0),Ht=BigInt(1);function Qt(t,n){const e=n.negate();return t?e:n}function Jt(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function $t(t,n){Jt(t,n);return{windows:Math.ceil(n/t)+1,windowSize:2**(t-1)}}function Se(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function Ae(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}const Ft=new WeakMap,Ie=new WeakMap;function te(t){return Ie.get(t)||1}function Oe(t){return pe(t.Fp),pt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Xt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */}function qe(t){void 0!==t.lowS&&gt("lowS",t.lowS),void 0!==t.prehash&&gt("prehash",t.prehash)}const{Ph:an,aT:un}=zt;class ln extends Error{constructor(n=""){super(n)}}const $={Err:ln,_tlv:{encode:(t,n)=>{const{Err:e}=$;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(1&n.length)throw new e("tlv.encode: unpadded data");const r=n.length/2,o=mt(r);if(o.length/2&128)throw new e("tlv.encode: long form length too big");const s=r>127?mt(o.length/2|128):"";return mt(t)+s+o+n},decode(t,n){const{Err:e}=$;let r=0;if(t<0||t>256)throw new e("tlv.encode: wrong tag");if(n.length<2||n[r++]!==t)throw new e("tlv.decode: wrong tlv");const o=n[r++];let c=0;if(!!(128&o)){const i=127&o;if(!i)throw new e("tlv.decode(long): indefinite length not supported");if(i>4)throw new e("tlv.decode(long): byte length is too big");const a=n.subarray(r,r+i);if(a.length!==i)throw new e("tlv.decode: length bytes not complete");if(0===a[0])throw new e("tlv.decode(long): zero leftmost byte");for(const d of a)c=c<<8|d;if(r+=i,c<128)throw new e("tlv.decode(long): not minimal encoding")}else c=o;const f=n.subarray(r,r+c);if(f.length!==c)throw new e("tlv.decode: wrong value length");return{v:f,l:n.subarray(r+c)}}},_int:{encode(t){const{Err:n}=$;if(t<G)throw new n("integer: negative integers are not allowed");let e=mt(t);if(8&Number.parseInt(e[0],16)&&(e="00"+e),1&e.length)throw new n("unexpected DER parsing assertion: unpadded hex");return e},decode(t){const{Err:n}=$;if(128&t[0])throw new n("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new n("invalid signature integer: unnecessary leading zero");return an(t)}},toSig(t){const{Err:n,_int:e,_tlv:r}=$,o="string"==typeof t?un(t):t;X(o);const{v:s,l:c}=r.decode(48,o);if(c.length)throw new n("invalid signature: left bytes after parsing");const{v:f,l:i}=r.decode(2,s),{v:a,l:d}=r.decode(2,i);if(d.length)throw new n("invalid signature: left bytes after parsing");return{r:e.decode(f),s:e.decode(a)}},hexFromSig(t){const{_tlv:n,_int:e}=$,s=n.encode(2,e.encode(t.r))+n.encode(2,e.encode(t.s));return n.encode(48,s)}},G=BigInt(0),C=BigInt(1),st=BigInt(2),kt=BigInt(3),_e=BigInt(4);function dn(t){const n=function fn(t){const n=Oe(t);pt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:o}=n;if(e){if(!r.eql(o,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if("object"!=typeof e||"bigint"!=typeof e.beta||"function"!=typeof e.splitScalar)throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...n})}(t),{Fp:e}=n,r=xe(n.n,n.nBitLength),o=n.toBytes||((b,u,w)=>{const m=u.toAffine();return D(Uint8Array.from([4]),e.toBytes(m.x),e.toBytes(m.y))}),s=n.fromBytes||(b=>{const u=b.subarray(1);return{x:e.fromBytes(u.subarray(0,e.BYTES)),y:e.fromBytes(u.subarray(e.BYTES,2*e.BYTES))}});function c(b){const{a:u,b:w}=n,m=e.sqr(b),p=e.mul(m,b);return e.add(e.add(p,e.mul(b,u)),w)}if(!e.eql(e.sqr(n.Gy),c(n.Gx)))throw new Error("bad generator point: equation left != right");function i(b){const{allowedPrivateKeyLengths:u,nByteLength:w,wrapPrivateKey:m,n:p}=n;if(u&&"bigint"!=typeof b){if(ut(b)&&(b=wt(b)),"string"!=typeof b||!u.includes(b.length))throw new Error("invalid private key");b=b.padStart(2*w,"0")}let B;try{B="bigint"==typeof b?b:Q(M("private key",b,w))}catch{throw new Error("invalid private key, expected hex or "+w+" bytes, got "+typeof b)}return m&&(B=H(B,p)),rt("private key",B,C,p),B}function a(b){if(!(b instanceof h))throw new Error("ProjectivePoint expected")}const d=Gt((b,u)=>{const{px:w,py:m,pz:p}=b;if(e.eql(p,e.ONE))return{x:w,y:m};const B=b.is0();null==u&&(u=B?e.ONE:e.inv(p));const _=e.mul(w,u),O=e.mul(m,u),S=e.mul(p,u);if(B)return{x:e.ZERO,y:e.ZERO};if(!e.eql(S,e.ONE))throw new Error("invZ was invalid");return{x:_,y:O}}),l=Gt(b=>{if(b.is0()){if(n.allowInfinityPoint&&!e.is0(b.py))return;throw new Error("bad point: ZERO")}const{x:u,y:w}=b.toAffine();if(!e.isValid(u)||!e.isValid(w))throw new Error("bad point: x or y not FE");const m=e.sqr(w),p=c(u);if(!e.eql(m,p))throw new Error("bad point: equation left != right");if(!b.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class h{constructor(u,w,m){if(this.px=u,this.py=w,this.pz=m,null==u||!e.isValid(u))throw new Error("x required");if(null==w||!e.isValid(w))throw new Error("y required");if(null==m||!e.isValid(m))throw new Error("z required");Object.freeze(this)}static fromAffine(u){const{x:w,y:m}=u||{};if(!u||!e.isValid(w)||!e.isValid(m))throw new Error("invalid affine point");if(u instanceof h)throw new Error("projective point not allowed");const p=B=>e.eql(B,e.ZERO);return p(w)&&p(m)?h.ZERO:new h(w,m,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){const w=e.invertBatch(u.map(m=>m.pz));return u.map((m,p)=>m.toAffine(w[p])).map(h.fromAffine)}static fromHex(u){const w=h.fromAffine(s(M("pointHex",u)));return w.assertValidity(),w}static fromPrivateKey(u){return h.BASE.multiply(i(u))}static msm(u,w){return function cn(t,n,e,r){if(Se(e,t),Ae(r,n),e.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const o=t.ZERO,s=ge(BigInt(e.length)),c=s>12?s-3:s>4?s-2:s?2:1,f=(1<<c)-1,i=new Array(f+1).fill(o);let d=o;for(let l=Math.floor((n.BITS-1)/c)*c;l>=0;l-=c){i.fill(o);for(let g=0;g<r.length;g++){const v=r[g],b=Number(v>>BigInt(l)&BigInt(f));i[b]=i[b].add(e[g])}let h=o;for(let g=i.length-1,v=o;g>0;g--)v=v.add(i[g]),h=h.add(v);if(d=d.add(h),0!==l)for(let g=0;g<c;g++)d=d.double()}return d}(h,r,u,w)}_setWindowSize(u){v.setWindowSize(this,u)}assertValidity(){l(this)}hasEvenY(){const{y:u}=this.toAffine();if(e.isOdd)return!e.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){a(u);const{px:w,py:m,pz:p}=this,{px:B,py:_,pz:O}=u,S=e.eql(e.mul(w,O),e.mul(B,p)),I=e.eql(e.mul(m,O),e.mul(_,p));return S&&I}negate(){return new h(this.px,e.neg(this.py),this.pz)}double(){const{a:u,b:w}=n,m=e.mul(w,kt),{px:p,py:B,pz:_}=this;let O=e.ZERO,S=e.ZERO,I=e.ZERO,A=e.mul(p,p),V=e.mul(B,B),R=e.mul(_,_),T=e.mul(p,B);return T=e.add(T,T),I=e.mul(p,_),I=e.add(I,I),O=e.mul(u,I),S=e.mul(m,R),S=e.add(O,S),O=e.sub(V,S),S=e.add(V,S),S=e.mul(O,S),O=e.mul(T,O),I=e.mul(m,I),R=e.mul(u,R),T=e.sub(A,R),T=e.mul(u,T),T=e.add(T,I),I=e.add(A,A),A=e.add(I,A),A=e.add(A,R),A=e.mul(A,T),S=e.add(S,A),R=e.mul(B,_),R=e.add(R,R),A=e.mul(R,T),O=e.sub(O,A),I=e.mul(R,V),I=e.add(I,I),I=e.add(I,I),new h(O,S,I)}add(u){a(u);const{px:w,py:m,pz:p}=this,{px:B,py:_,pz:O}=u;let S=e.ZERO,I=e.ZERO,A=e.ZERO;const V=n.a,R=e.mul(n.b,kt);let T=e.mul(w,B),K=e.mul(m,_),y=e.mul(p,O),x=e.add(w,m),E=e.add(B,_);x=e.mul(x,E),E=e.add(T,K),x=e.sub(x,E),E=e.add(w,p);let q=e.add(B,O);return E=e.mul(E,q),q=e.add(T,y),E=e.sub(E,q),q=e.add(m,p),S=e.add(_,O),q=e.mul(q,S),S=e.add(K,y),q=e.sub(q,S),A=e.mul(V,E),S=e.mul(R,y),A=e.add(S,A),S=e.sub(K,A),A=e.add(K,A),I=e.mul(S,A),K=e.add(T,T),K=e.add(K,T),y=e.mul(V,y),E=e.mul(R,E),K=e.add(K,y),y=e.sub(T,y),y=e.mul(V,y),E=e.add(E,y),T=e.mul(K,E),I=e.add(I,T),T=e.mul(q,E),S=e.mul(x,S),S=e.sub(S,T),T=e.mul(x,K),A=e.mul(q,A),A=e.add(A,T),new h(S,I,A)}subtract(u){return this.add(u.negate())}is0(){return this.equals(h.ZERO)}wNAF(u){return v.wNAFCached(this,u,h.normalizeZ)}multiplyUnsafe(u){const{endo:w,n:m}=n;rt("scalar",u,G,m);const p=h.ZERO;if(u===G)return p;if(this.is0()||u===C)return this;if(!w||v.hasPrecomputes(this))return v.wNAFCachedUnsafe(this,u,h.normalizeZ);let{k1neg:B,k1:_,k2neg:O,k2:S}=w.splitScalar(u),I=p,A=p,V=this;for(;_>G||S>G;)_&C&&(I=I.add(V)),S&C&&(A=A.add(V)),V=V.double(),_>>=C,S>>=C;return B&&(I=I.negate()),O&&(A=A.negate()),A=new h(e.mul(A.px,w.beta),A.py,A.pz),I.add(A)}multiply(u){const{endo:w,n:m}=n;let p,B;if(rt("scalar",u,C,m),w){const{k1neg:_,k1:O,k2neg:S,k2:I}=w.splitScalar(u);let{p:A,f:V}=this.wNAF(O),{p:R,f:T}=this.wNAF(I);A=v.constTimeNegate(_,A),R=v.constTimeNegate(S,R),R=new h(e.mul(R.px,w.beta),R.py,R.pz),p=A.add(R),B=V.add(T)}else{const{p:_,f:O}=this.wNAF(u);p=_,B=O}return h.normalizeZ([p,B])[0]}multiplyAndAddUnsafe(u,w,m){const p=h.BASE,B=(O,S)=>S!==G&&S!==C&&O.equals(p)?O.multiply(S):O.multiplyUnsafe(S),_=B(this,w).add(B(u,m));return _.is0()?void 0:_}toAffine(u){return d(this,u)}isTorsionFree(){const{h:u,isTorsionFree:w}=n;if(u===C)return!0;if(w)return w(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:u,clearCofactor:w}=n;return u===C?this:w?w(h,this):this.multiplyUnsafe(n.h)}toRawBytes(u=!0){return gt("isCompressed",u),this.assertValidity(),o(h,this,u)}toHex(u=!0){return gt("isCompressed",u),wt(this.toRawBytes(u))}}h.BASE=new h(n.Gx,n.Gy,e.ONE),h.ZERO=new h(e.ZERO,e.ONE,e.ZERO);const g=n.nBitLength,v=function sn(t,n){return{constTimeNegate:Qt,hasPrecomputes:e=>1!==te(e),unsafeLadder(e,r,o=t.ZERO){let s=e;for(;r>Be;)r&Ht&&(o=o.add(s)),s=s.double(),r>>=Ht;return o},precomputeWindow(e,r){const{windows:o,windowSize:s}=$t(r,n),c=[];let f=e,i=f;for(let a=0;a<o;a++){i=f,c.push(i);for(let d=1;d<s;d++)i=i.add(f),c.push(i);f=i.double()}return c},wNAF(e,r,o){const{windows:s,windowSize:c}=$t(e,n);let f=t.ZERO,i=t.BASE;const a=BigInt(2**e-1),d=2**e,l=BigInt(e);for(let h=0;h<s;h++){const g=h*c;let v=Number(o&a);o>>=l,v>c&&(v-=d,o+=Ht);const b=g,u=g+Math.abs(v)-1,w=h%2!=0,m=v<0;0===v?i=i.add(Qt(w,r[b])):f=f.add(Qt(m,r[u]))}return{p:f,f:i}},wNAFUnsafe(e,r,o,s=t.ZERO){const{windows:c,windowSize:f}=$t(e,n),i=BigInt(2**e-1),a=2**e,d=BigInt(e);for(let l=0;l<c;l++){const h=l*f;if(o===Be)break;let g=Number(o&i);if(o>>=d,g>f&&(g-=a,o+=Ht),0===g)continue;let v=r[h+Math.abs(g)-1];g<0&&(v=v.negate()),s=s.add(v)}return s},getPrecomputes(e,r,o){let s=Ft.get(r);return s||(s=this.precomputeWindow(r,e),1!==e&&Ft.set(r,o(s))),s},wNAFCached(e,r,o){const s=te(e);return this.wNAF(s,this.getPrecomputes(s,e,o),r)},wNAFCachedUnsafe(e,r,o,s){const c=te(e);return 1===c?this.unsafeLadder(e,r,s):this.wNAFUnsafe(c,this.getPrecomputes(c,e,o),r,s)},setWindowSize(e,r){Jt(r,n),Ie.set(e,r),Ft.delete(e)}}}(h,n.endo?Math.ceil(g/2):g);return{CURVE:n,ProjectivePoint:h,normPrivateKeyToScalar:i,weierstrassEquation:c,isWithinCurveOrder:function f(b){return yt(b,C,n.n)}}}function gn(t){const n=function hn(t){const n=Oe(t);return pt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}(t),{Fp:e,n:r}=n,o=e.BYTES+1,s=2*e.BYTES+1;function c(y){return H(y,r)}function f(y){return Ut(y,r)}const{ProjectivePoint:i,normPrivateKeyToScalar:a,weierstrassEquation:d,isWithinCurveOrder:l}=dn({...n,toBytes(y,x,E){const q=x.toAffine(),N=e.toBytes(q.x),k=D;return gt("isCompressed",E),E?k(Uint8Array.from([x.hasEvenY()?2:3]),N):k(Uint8Array.from([4]),N,e.toBytes(q.y))},fromBytes(y){const x=y.length,E=y[0],q=y.subarray(1);if(x!==o||2!==E&&3!==E){if(x===s&&4===E){return{x:e.fromBytes(q.subarray(0,e.BYTES)),y:e.fromBytes(q.subarray(e.BYTES,2*e.BYTES))}}throw new Error("invalid Point, expected length of "+o+", or uncompressed "+s+", got "+x)}{const N=Q(q);if(!yt(N,C,e.ORDER))throw new Error("Point is not on curve");const k=d(N);let P;try{P=e.sqrt(k)}catch(W){const j=W instanceof Error?": "+W.message:"";throw new Error("Point is not on curve"+j)}return!(1&~E)!==((P&C)===C)&&(P=e.neg(P)),{x:N,y:P}}}}),h=y=>wt(nt(y,n.nByteLength));function g(y){return y>r>>C}const b=(y,x,E)=>Q(y.slice(x,E));class u{constructor(x,E,q){this.r=x,this.s=E,this.recovery=q,this.assertValidity()}static fromCompact(x){const E=n.nByteLength;return x=M("compactSignature",x,2*E),new u(b(x,0,E),b(x,E,2*E))}static fromDER(x){const{r:E,s:q}=$.toSig(M("DER",x));return new u(E,q)}assertValidity(){rt("r",this.r,C,r),rt("s",this.s,C,r)}addRecoveryBit(x){return new u(this.r,this.s,x)}recoverPublicKey(x){const{r:E,s:q,recovery:N}=this,k=O(M("msgHash",x));if(null==N||![0,1,2,3].includes(N))throw new Error("recovery id invalid");const P=2===N||3===N?E+n.n:E;if(P>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const z=1&N?"03":"02",F=i.fromHex(z+h(P)),W=f(P),j=c(-k*W),Et=c(q*W),ft=i.BASE.multiplyAndAddUnsafe(F,j,Et);if(!ft)throw new Error("point at infinify");return ft.assertValidity(),ft}hasHighS(){return g(this.s)}normalizeS(){return this.hasHighS()?new u(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return bt(this.toDERHex())}toDERHex(){return $.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return bt(this.toCompactHex())}toCompactHex(){return h(this.r)+h(this.s)}}const w={isValidPrivateKey(y){try{return a(y),!0}catch{return!1}},normPrivateKeyToScalar:a,randomPrivateKey:()=>{const y=ve(n.n);return function on(t,n,e=!1){const r=t.length,o=Ee(n),s=ve(n);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const f=H(e?Pt(t):Q(t),n-L)+L;return e?jt(f,o):nt(f,o)}(n.randomBytes(y),n.n)},precompute:(y=8,x=i.BASE)=>(x._setWindowSize(y),x.multiply(BigInt(3)),x)};function p(y){const x=ut(y),E="string"==typeof y,q=(x||E)&&y.length;return x?q===o||q===s:E?q===2*o||q===2*s:y instanceof i}const _=n.bits2int||function(y){if(y.length>8192)throw new Error("input is too large");const x=Q(y),E=8*y.length-n.nBitLength;return E>0?x>>BigInt(E):x},O=n.bits2int_modN||function(y){return c(_(y))},S=Kt(n.nBitLength);function I(y){return rt("num < 2^"+n.nBitLength,y,G,S),nt(y,n.nByteLength)}function A(y,x,E=V){if(["recovered","canonical"].some(lt=>lt in E))throw new Error("sign() legacy options not supported");const{hash:q,randomBytes:N}=n;let{lowS:k,prehash:P,extraEntropy:z}=E;null==k&&(k=!0),y=M("msgHash",y),qe(E),P&&(y=M("prehashed msgHash",q(y)));const F=O(y),W=a(x),j=[I(W),I(F)];if(null!=z&&!1!==z){const lt=!0===z?N(e.BYTES):z;j.push(M("extraEntropy",lt))}const Et=D(...j),ft=F;return{seed:Et,k2sig:function ie(lt){const vt=_(lt);if(!l(vt))return;const ce=f(vt),_t=i.BASE.multiply(vt).toAffine(),dt=c(_t.x);if(dt===G)return;const Nt=c(ce*c(ft+dt*W));if(Nt===G)return;let Bt=(_t.x===dt?0:2)|Number(_t.y&C),Ve=Nt;return k&&g(Nt)&&(Ve=function v(y){return g(y)?c(-y):y}(Nt),Bt^=1),new u(dt,Ve,Bt)}}}const V={lowS:n.lowS,prehash:!1},R={lowS:n.lowS,prehash:!1};return i.BASE._setWindowSize(8),{CURVE:n,getPublicKey:function m(y,x=!0){return i.fromPrivateKey(y).toRawBytes(x)},getSharedSecret:function B(y,x,E=!0){if(p(y))throw new Error("first arg must be private key");if(!p(x))throw new Error("second arg must be public key");return i.fromHex(x).multiply(a(y)).toRawBytes(E)},sign:function T(y,x,E=V){const{seed:q,k2sig:N}=A(y,x,E),k=n;return me(k.hash.outputLen,k.nByteLength,k.hmac)(q,N)},verify:function K(y,x,E,q=R){const N=y;x=M("msgHash",x),E=M("publicKey",E);const{lowS:k,prehash:P,format:z}=q;if(qe(q),"strict"in q)throw new Error("options.strict was renamed to lowS");if(void 0!==z&&"compact"!==z&&"der"!==z)throw new Error("format must be compact or der");const F="string"==typeof N||ut(N),W=!F&&!z&&"object"==typeof N&&null!==N&&"bigint"==typeof N.r&&"bigint"==typeof N.s;if(!F&&!W)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let j,Et;try{if(W&&(j=new u(N.r,N.s)),F){try{"compact"!==z&&(j=u.fromDER(N))}catch(Bt){if(!(Bt instanceof $.Err))throw Bt}!j&&"der"!==z&&(j=u.fromCompact(N))}Et=i.fromHex(E)}catch{return!1}if(!j||k&&j.hasHighS())return!1;P&&(x=n.hash(x));const{r:ft,s:ie}=j,lt=O(x),vt=f(ie),ce=c(lt*vt),_t=c(ft*vt),dt=i.BASE.multiplyAndAddUnsafe(Et,ce,_t)?.toAffine();return!!dt&&c(dt.x)===ft},ProjectivePoint:i,Signature:u,utils:w}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function bn(t){return{hash:t,hmac:(n,...e)=>le(t,n,(0,U.Id)(...e)),randomBytes:U.po}}const pn=Q;function it(t,n){if(St(t),St(n),t<0||t>=1<<8*n)throw new Error("invalid I2OSP input: "+t);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=255&t,t>>>=8;return new Uint8Array(e)}function xn(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function St(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Ne(t,n,e){pt(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:s,hash:c,expand:f,DST:i}=e;X(t),St(n);const a="string"==typeof i?Rt(i):i,d=r.toString(2).length,l=Math.ceil((d+o)/8),h=n*s*l;let g;if("xmd"===f)g=function En(t,n,e,r){X(t),X(n),St(e),n.length>255&&(n=r(D(Rt("H2C-OVERSIZE-DST-"),n)));const{outputLen:o,blockLen:s}=r,c=Math.ceil(e/o);if(e>65535||c>255)throw new Error("expand_message_xmd: invalid lenInBytes");const f=D(n,it(n.length,1)),i=it(0,s),a=it(e,2),d=new Array(c),l=r(D(i,t,a,it(0,1),f));d[0]=r(D(l,it(1,1),f));for(let g=1;g<=c;g++){const v=[xn(l,d[g-1]),it(g+1,1),f];d[g]=r(D(...v))}return D(...d).slice(0,e)}(t,a,h,c);else if("xof"===f)g=function vn(t,n,e,r,o){if(X(t),X(n),St(e),n.length>255){const s=Math.ceil(2*r/8);n=o.create({dkLen:s}).update(Rt("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:e}).update(t).update(it(e,2)).update(n).update(it(n.length,1)).digest()}(t,a,h,o,c);else{if("_internal_pass"!==f)throw new Error('expand must be "xmd" or "xof"');g=t}const v=new Array(n);for(let b=0;b<n;b++){const u=new Array(s);for(let w=0;w<s;w++){const m=l*(w+b*s),p=g.subarray(m,m+l);u[w]=H(pn(p),r)}v[b]=u}return v}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const At=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Zt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),It=BigInt(1),Vt=BigInt(2),Ce=(t,n)=>(t+n/Vt)/n;function Te(t){const n=At,e=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),c=BigInt(23),f=BigInt(44),i=BigInt(88),a=t*t*t%n,d=a*a*t%n,l=Y(d,e,n)*d%n,h=Y(l,e,n)*d%n,g=Y(h,Vt,n)*a%n,v=Y(g,o,n)*g%n,b=Y(v,s,n)*v%n,u=Y(b,f,n)*b%n,w=Y(u,i,n)*u%n,m=Y(w,f,n)*b%n,p=Y(m,e,n)*d%n,B=Y(p,c,n)*v%n,_=Y(B,r,n)*a%n,O=Y(_,Vt,n);if(!ct.eql(ct.sqr(O),t))throw new Error("Cannot find square root");return O}const ct=xe(At,void 0,void 0,{sqrt:Te}),Ot=function yn(t,n){const e=r=>gn({...t,...bn(r)});return{...e(n),create:e}}({a:BigInt(0),b:BigInt(7),Fp:ct,n:Zt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=Zt,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-It*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=e,c=BigInt("0x100000000000000000000000000000000"),f=Ce(s*t,n),i=Ce(-r*t,n);let a=H(t-f*e-i*o,n),d=H(-f*r-i*s,n);const l=a>c,h=d>c;if(l&&(a=n-a),h&&(d=n-d),a>c||d>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:a,k2neg:h,k2:d}}}},Ct),Le=BigInt(0),Re={};function Mt(t,...n){let e=Re[t];if(void 0===e){const r=Ct(Uint8Array.from(t,o=>o.charCodeAt(0)));e=D(r,r),Re[t]=e}return Ct(D(e,...n))}const ee=t=>t.toRawBytes(!0).slice(1),ne=t=>nt(t,32),re=t=>H(t,At),qt=t=>H(t,Zt),oe=Ot.ProjectivePoint;function se(t){let n=Ot.utils.normPrivateKeyToScalar(t),e=oe.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:qt(-n),bytes:ee(e)}}function Ue(t){rt("x",t,It,At);const n=re(t*t);let r=Te(re(n*t+BigInt(7)));r%Vt!==Le&&(r=re(-r));const o=new oe(t,r,It);return o.assertValidity(),o}const xt=Q;function He(...t){return qt(xt(Mt("BIP0340/challenge",...t)))}function ke(t,n,e){const r=M("signature",t,64),o=M("message",n),s=M("publicKey",e,32);try{const c=Ue(xt(s)),f=xt(r.subarray(0,32));if(!yt(f,It,At))return!1;const i=xt(r.subarray(32,64));if(!yt(i,It,Zt))return!1;const a=He(ne(f),ee(c),o),d=((t,n,e)=>oe.BASE.multiplyAndAddUnsafe(t,n,e))(c,i,qt(-a));return!(!d||!d.hasEvenY()||d.toAffine().x!==f)}catch{return!1}}const qn={getPublicKey:function In(t){return se(t).bytes},sign:function On(t,n,e=(0,U.po)(32)){const r=M("message",t),{bytes:o,scalar:s}=se(n),c=M("auxRand",e,32),f=ne(s^xt(Mt("BIP0340/aux",c))),i=Mt("BIP0340/nonce",f,o,r),a=qt(xt(i));if(a===Le)throw new Error("sign failed: k is zero");const{bytes:d,scalar:l}=se(a),h=He(d,o,r),g=new Uint8Array(64);if(g.set(d,0),g.set(ne(qt(l+h*s)),32),!ke(g,r,o))throw new Error("sign: Invalid signature produced");return g},verify:ke,utils:{randomPrivateKey:Ot.utils.randomPrivateKey,lift_x:Ue,pointToBytes:ee,numberToBytesBE:nt,bytesToNumberBE:Q,taggedHash:Mt,mod:H}},_n=function Bn(t,n){const e=n.map(r=>Array.from(r).reverse());return(r,o)=>{const[s,c,f,i]=e.map(a=>a.reduce((d,l)=>t.add(t.mul(d,r),l)));return r=t.div(s,c),o=t.mul(o,t.div(f,i)),{x:r,y:o}}}(ct,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))),Nn=function mn(t,n){if(pe(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=function wn(t,n){const e=t.ORDER;let r=G;for(let v=e-C;v%st===G;v/=st)r+=C;const o=r,s=st<<o-C-C,c=s*st,f=(e-C)/c,i=(f-C)/st,a=c-C,d=s,l=t.pow(n,f),h=t.pow(n,(f+C)/st);let g=(v,b)=>{let u=l,w=t.pow(b,a),m=t.sqr(w);m=t.mul(m,b);let p=t.mul(v,m);p=t.pow(p,i),p=t.mul(p,w),w=t.mul(p,b),m=t.mul(p,v);let B=t.mul(m,w);p=t.pow(B,d);let _=t.eql(p,t.ONE);w=t.mul(m,h),p=t.mul(B,u),m=t.cmov(w,m,_),B=t.cmov(p,B,_);for(let O=o;O>C;O--){let S=O-st;S=st<<S-C;let I=t.pow(B,S);const A=t.eql(I,t.ONE);w=t.mul(m,u),u=t.mul(u,u),I=t.mul(B,u),m=t.cmov(w,m,A),B=t.cmov(I,B,A)}return{isValid:_,value:m}};if(t.ORDER%_e===kt){const v=(t.ORDER-kt)/_e,b=t.sqrt(t.neg(n));g=(u,w)=>{let m=t.sqr(w);const p=t.mul(u,w);m=t.mul(m,p);let B=t.pow(m,v);B=t.mul(B,p);const _=t.mul(B,b),O=t.mul(t.sqr(B),w),S=t.eql(O,u);return{isValid:S,value:t.cmov(_,B,S)}}}return g}(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,s,c,f,i,a,d,l;o=t.sqr(r),o=t.mul(o,n.Z),s=t.sqr(o),s=t.add(s,o),c=t.add(s,t.ONE),c=t.mul(c,n.B),f=t.cmov(n.Z,t.neg(s),!t.eql(s,t.ZERO)),f=t.mul(f,n.A),s=t.sqr(c),a=t.sqr(f),i=t.mul(a,n.A),s=t.add(s,i),s=t.mul(s,c),a=t.mul(a,f),i=t.mul(a,n.B),s=t.add(s,i),d=t.mul(o,c);const{isValid:h,value:g}=e(s,a);l=t.mul(o,r),l=t.mul(l,g),d=t.cmov(d,c,h),l=t.cmov(l,g,h);const v=t.isOdd(r)===t.isOdd(l);return l=t.cmov(t.neg(l),l,v),d=t.div(d,f),{x:d,y:l}}}(ct,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:ct.create(BigInt("-11"))}),Ze=function Sn(t,n,e){if("function"!=typeof n)throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const s=Ne(r,2,{...e,DST:e.DST,...o}),c=t.fromAffine(n(s[0])),f=t.fromAffine(n(s[1])),i=c.add(f).clearCofactor();return i.assertValidity(),i},encodeToCurve(r,o){const s=Ne(r,1,{...e,DST:e.encodeDST,...o}),c=t.fromAffine(n(s[0])).clearCofactor();return c.assertValidity(),c},mapToCurve(r){if(!Array.isArray(r))throw new Error("mapToCurve: expected array of bigints");for(const s of r)if("bigint"!=typeof s)throw new Error("mapToCurve: expected array of bigints");const o=t.fromAffine(n(r)).clearCofactor();return o.assertValidity(),o}}}(Ot.ProjectivePoint,t=>{const{x:n,y:e}=Nn(ct.create(t[0]));return _n(n,e)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:ct.ORDER,m:1,k:128,expand:"xmd",hash:Ct}),Cn=Ze.hashToCurve,Tn=Ze.encodeToCurve}}]);